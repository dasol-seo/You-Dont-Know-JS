# You Don't Know JS: Up & Going

# Chapter 1: Into Programming

*You Don't Know JS* (*YDKJS*) 시리즈에 오신걸 환영합니다.

*Up & Going*은 프로그래밍의 여러가지 기본 개념에 대한 소개입니다. -- 물론 우리는 주로 자바스크립트를 집중해서 배울 것입니다(가끔은 JS 외적인 부분도 포함 합니다). -- 그리고 시리즈의 나머지 부분들에 대한 접근법과 이해하기 위한 방법이기도 합니다. 특히 여러분이 프로그래밍 혹은 자바스크립트에 입문하는 경우라면 이 책은 *첫 시작*에 필요한 것들을 간단히 설명해 줄 것입니다.

이 책은 프로그래밍 기본원리에 대해서 아주 자세히 시작합니다. 이 책은 주로 여러분이 사전 프로그래밍 경험이 거의 없는 상태에서 *YDKJS*를 처음 시작하는 경우와, 자바스크립트에 대한 내용을 통해 프로그래밍에 대한 이해를 시작하려는 사람을 대상으로 합니다.

1장은 *프로그래밍을 시작*하는데 있어서 여러분들이 배워야 하고 연습해야 하는 것들에 대해 전반적으로 다룰 것입니다. 이러한 주제들에 대해 더 자세히 설명해주는 다른 훌륭한 프로그래밍 소개 자료들이 많습니다. 이 장 뿐만 아니라 다른 자료들도 참고하시길 권장드립니다.

전반적인 프로그래밍 기초에 편해지셨다면, 2장은 자바스크립트에 조금 더 익숙해지도록 도와 줄 것입니다. 2장은 자바스크립트가 무엇인지 소개 합니다. 다시 말씀드리지만, 이 시리즈는 종합적인 가이드가 아닙니다. 다른 YDKJS 책들이 준비되어 있습니다!

이미 자바스크립트에 어느정도 익숙하시다면, YDKJS에서 기대할 수 있는 내용을 잠깐 엿볼 수 있는 3장을 먼저 살펴보고 바로 (다른 시리즈로) 건너 뛰셔도 좋습니다!

## 코드

처음부터 시작해봅시다.

종종 *소스코드* 혹은 *코드*라고 언급되는 프로그램은 컴퓨터에게 업무를 수행하도록 전달하는 특별한 명령의 집합 입니다. 자바스크립트로 직접 브라우저에 있는 개발자 콘솔에서 직접 코드를 입력할수 있지만 보통 코드는 텍스트 파일로 저장이됩니다. 이는 곧 다루게 될 것입니다.

유효한 형식과 명령들의 조합으로 구성된 규칙들을 *컴퓨터 언어*라고 합니다. 때로는 *문법*이라고도 합니다. 영어에서 처럼, 단어를 철자하는 방법과 단어와 구두점을 사용하여 문장을 만드는 방법과 아주 비슷합니다.

### 문

컴퓨터 언어에서는 단어, 숫자, 특정한 일을 수행하는 연산자의 집합을 *문*이라고 합니다. 자바스크립트에서, 문은 다음과 같습니다.

```js
a = b * 2;
```

철자 `a`와 `b`를 *변수*라고 합니다.("변수"를 참고하세요). 이는 어떤 물건을 보관 할 수 있는 단순한 상자와 같습니다. 변수는 프로그램에서 사용되는 값(숫자 42와 같은)들을 가지고 있습니다. 값 자체를 기호로 표시된 상징적인 값 처럼 생각할 수 있습니다.

반대로, 2는 *상수값*이라고 하는 단순한 값 그 자체 입니다. 왜냐하면 변수가 어디에 저장되지 않고 독립적으로 있기 때문입니다.

`=` 과 `*` 문자들은 *연산자*("Operators"를 참고하세요) 입니다. 값과 변수를 이용하여 할당과 수학곱셈과 같은 동작을 수행합니다.

자바스크립트에서 대부분의 문은 세미콜론(`;`)으로 끝납니다.

문 `a = b * 2;` 는 대략적으로 컴퓨터에게 현재 값을 변수 `b`에 저장시키고, 그 값을 `2`로 곱한다음에, 돌려받은 결과값을 `a` 라고하는 변수에 저장하라고 명령 합니다.

프로그램은 단지 여러 문들의 집합입니다. 각각의 문들은 프로그램의 목적을 수행하기 위해 모든 단계에서 차례로 기술됩니다.

### 표현식

문은 하나 이상의 *표현식*으로 이루어 집니다. 표현식은 변수나 값, 혹은 변수들의 집합이나 연산자와 함께 결합된 값들에 대한 참조입니다.

예를들면:

```js
a = b * 2;
```

이 문은 네가지 표현식을 포함하고 있습니다:

* `2`는 *상수 값 표현식* 입니다.
* `b`는 현재값을 가져오는 *변수 표현식* 입니다.
* `b * 2`는 곱셈을 하는 *산술 표현식* 입니다.
* `a = b * 2`는 *할당 표현식* 입니다. 이는, `b * 2` 표현식을 변수 `a`에 할당하는 것입니다.(할당에 대해서는 다음에 자세히 다루겠습니다.)

아래와 같이, 독립적으로 있는 일반적인 표현식은 또한 *표현문*이기도 합니다.

```js
b * 2;
```

이러한 표현문은 일반적이지 않고 유용하지도 않을뿐더러 프로그램 실행에 어떠한 영향도 주지 않습니다. 즉 `b` 값을 가져와서 `2`로 곱셈을 하지만, 그 결과값으로 어떠한 것도 수행하지 않습니다.

전체문은 함수호출 표현식 자체 이므로, 더 일반적인 표현문은 *호출 표현식* 문("함수"를 확인해보세요) 입니다.

```js
alert( a );
```

### 프로그램 실행하기

프로그래밍을 할 때의 문집합들은 어떻게 컴퓨터가 원하는 동작을 수행하게 만들수 있을까요? 프로그램은 *실행*이 필요합니다. 이는 또한 *프로그램 실행* 이라고도 합니다.

`a = b * 2` 와 같은 문은 개발자들에게는 읽고 쓰기 쉽습니다. 하지만 컴퓨터가 바로 이해할 수 있는 형식은 아닙니다. 그래서 컴퓨터(*인터프리터* 혹은 *컴파일러*)에 있는 특별한 도구가 컴퓨터가 이해할 수 있는 명령어로 코드를 해석하는것에 사용됩니다.

몇몇 컴퓨터 언어같은경우, 명령어 해석이 주로 위에서 아래로, 한 줄씩, 프로그램이 실행될때 마다 이루어 집니다. 이와 같은 방법을 *해석* 이라고도 합니다.

몇몇 다른 언어들 경우에는, 해석이 미리 이루어집니다. 이러한 것을 *컴파일* 한다고 합니다. 그래서 프로그램 *실행*이 나중에 수행되고, 컴파일 컴퓨터 명령어는 미리 실행 준비를 합니다.

대체로 자바스크립트가 *해석* 된다고 주장합니다. 왜냐하면 자바스크립트 소스 코드는 실행 될때마다 처리 되기 때문입니다. 하지만, 이는 완전히 정확하지 않습니다. 사실 자바스크립트 엔진은 즉시 프로그램을 *컴파일* 하고 나서 컴파일된 코드를 실행합니다.

**참고:** 자바스크립트 컴파일링에대해 더 자세히 알고 싶으시면, *Scope & Closures* 시리즈의 처음 두 장을 보세요

## 직접 해보기

이 장은 자바스크립트로 되어있는 간단한 코드 스니펫으로 각 프로그래밍 개념에 대해서 소개할 것입니다.

강조해도 지나치지 않습니다: 이 장을 진행하는 동안 여러분은 아마 여러번 반복해서 공부해야 할 것입니다. 코드를 직접 치면서 각 개념들을 연습하세요. 가장 쉬운 방법은 여러분의 브라우저(Firefox, Chrome, IE, etc.)의 개발자 도구에 있는 콘솔을 열어 사용 하는 것입니다.

**팁:** 일반적으로, 키보드 단축키 혹은 메뉴 아이템에서 개발자 도구 콘솔을 열 수 있습니다. 여러분이 가장 선호하는 브라우저에서 콘솔실행과 사용법에 대한 더 자세한 정보를 알고 싶으시면, "개발자 도구 정복하기" (http://blog.teamtreehouse.com/mastering-developer-tools-console)를 참고하세요. 한번에 여러 줄을 콘솔에 입력하려면, `<shift> + <enter>`를 사용하세요. 여러분이 `<enter>`를 입력한다면, 콘솔은 여러분이 입력한 모든 것을 실행할것 입니다.

콘솔에서 코드 실행 과정을 알아봅시다. 우선, 브라우저에서 빈탭 열기를 권장드립니다. 저는 `about:blank`를 주소바에 입력하는 것을 선호합니다. 그러고나서, 위에서 말씀드린것처럼 개발자 콘솔을 열어보세요.

그럼, 이 코드를 입력하고 어떻게 실행되는지 보세요.

```js
a = 21;

b = a * 2;

console.log( b );
```

위에 코드를 크롬 콘솔에 입력하시면 다음과 같이 보일것입니다:

<img src="fig1.png" width="500">

계속해서 실행해보세요. 프로그래밍을 배우는 데 최고의 방법은 코딩을 하는 것입니다!

### 출력

이전 코드 스니펫에서 우리는 `console.log(..)`를 사용했습니다. 간략하게 이 코드가 의미하는 바가 무엇인지 살펴보겠습니다.

눈치 채셨겠지만, 이렇게 하는 것이 바로 개발자 콘솔에서 텍스트(유저에게는 *출력*이라고 하는)를 출력하는 방법입니다.

첫번째로, `log( b )` 부분은 함수 호출("함수"를 참고하세요)을 참조 하게 됩니다. 이 말은 즉, 값을 받아서 콘솔에 출력하도록 변수`b`를 함수에 전달 해주었습니다.

두번째로, `console.` 부분은 `log(..)`함수가 위치해있는 객체를 참조합니다. 우리는 2장에서 객체와 그 속성들을 상세히 다룰 것입니다.

출력물을 만드는 다른 한가지 방법은 `alert(..)` 문을 실행하는 것입니다. 예를들면:

```js
alert( b );
```

실행을 하면 콘솔에 출력이 되지않고, 변수`b` 내용과 함께 “OK” 박스가 뜨게됩니다. 하지만, 일반적으로 코딩을 연습 할 때에는 `alert(..)`을 사용하는 것보다는 더 쉬운 `console.log(..)`를 사용합니다. 왜냐하면 브라우저의 끊김없이 한번에 많은 값들을 출력할 수 있기 때문입니다.

이 책에서, 우리는 출력으로 `console.log(..)`를 사용할 것입니다.

### 입력

출력값에 대해서 이야기하는동안, 여러분은 아마도 *입력값*(유저에게 정보를 받는)에 대해 궁금했을 것입니다.

HTML페이지에서 유저가 입력을 하게 할 수 있는 가장 흔한 방법은 form엘레멘트(text boxes같은)를 보여주고 입력을 받는 것입니다. 그 후 JS를 사용하여 그 입력 값들을 여러분의 프로그램의 변수로 읽을 수 있게 만들어야 합니다.

하지만 간단한 학습과 이 책을 통해 여러분이 배워갈 부분을 증명하고 실습해보기 위한 쉬운 방법도 있습니다. `prompt(..)`함수를 이용 해보세요:

```js
age = prompt( "Please tell me your age:" );

console.log( age );
```

예상하셨듯이, 여러분이 `prompt(..)`에 전달한 메시지가(`"Please tell me your age:"`) 나타날 것입니다.

다음과 같이 보일 것 입니다.

<img src="fig2.png" width="500">

“OK” 클릭으로 입력 텍스트를 제출하면, `console.log(..)`에서 나오는 *출력*을 통해 여러분이 입력한 값이 `age`에 저장되는 것을 확인할 수 있을 것입니다.

<img src="fig3.png" width="500">

기초 프로그래밍에 대한 개념을 배우는 것을 쉽게 하기 위하여 이 책의 예제들은 입력값을 필요로 하지 않습니다. 하지만 여러분에게 실습이 필요하다고 생각된다면 예제의 input을 `prompt(..)`와 함께 사용해보세요.

## 연산자

연산자는 변수와 값에 대해 어떠한 행동을 수행하는 방법입니다. 우리는 이미 `=` 와 `*`, 두 개의 자바스크립트 연산자를 보았습니다.

`*` 연산자는 수학적으로 곱셈 연산을 수행합니다. 간단하죠?

`=` 동등 연산자는 *할당*에 사용합니다. 첫 번째로 우리는 `=` 연산자의 *오른쪽 부분*부터(값) 계산한 후 왼편(변수)에서 미리 정해놓은 변수에 할당합니다.

**주의:** 여러분 중 몇몇은 `a = 42` 대신 `42 -> a`(이 형식은 자바스크립트에서는 사용할 수 없습니다.)처럼 순서를 뒤집어서 왼편에는 값, 오른편에는 변수를 넣는 형식이 익숙해서, 할당을 역순으로 표현하는 것이 이상하게 보일 수 있습니다. 안타깝지만, 현대의 여러 프로그래밍 언어는 `a = 42`와 같은 비슷한 형식을 주로 사용하고 있습니다. 만약 이러한 할당 방식이 자연스럽지 않다고 느낀다면, 시간을 들여 연습하고 익숙해져야 합니다.

생각해보세요:

```js
a = 2;
b = a + 1;
```

위 코드에서, 우리는 변수 `a`에 `2` 값을 할당합니다. 그런 다음 변숫값 `a`(아직은 `2`)를 갖고 여기에 `1`을 추가하여 값 `3`을 만든 다음 그 값을 `b` 변수에 저장합니다.

엄밀히 말하자면 연산자는 아니지만, 여러분은 모든 프로그램에서 *변수*("Variables"을 참고하세요)를 *선언*(혹은 *생성*)하려는 방법으로 보통 `var` 키워드가 필요할 것입니다. 

여러분은 변수를 사용하기 전에 항상 이름과 함께 선언해야 합니다. 물론 각 *스코프*("Scope"을 참고하세요)에서 한 번만 선언하고 그 후에는 얼마든지 그 변수를 사용할 수 있습니다. 예를 들어:

```js
var a = 20;

a = a + 1;
a = a * 2;

console.log( a );	// 42
```

아래는 자바스크립트에서 흔하게 사용하는 연산자들입니다:

* 할당(Assignment): `=`는 `a = 2`와 같이 사용한다.
* 수학적 계산: `+` 덧셈, `-` 뺄셈, `*` 곱셈, 그리고 `/` 나눗셈, 이는 `a * 3`과 같이 사용합니다.
* 혼합 할당(Compound Assignment): `+=`, `-=`, `*=`, 그리고 `/=`는 수학적 연산자와 할당 연산자를 결합하여 사용하는 혼합 연산자입니다. 이는 `a += 2`와 같이 사용합니다. (`a = a + 2`와 같은 의미입니다.)
* 증가(Increment)/감소(Decrement): `++` (증가), `--` (감소), 이는 `a++`와 같이 사용합니다.(`a = a + 1`와 같은 의미입니다.)
* 객체 속성 접근자(Object Property Access): `.` 이는 `console.log()`와 같이 사용합니다.

    객체는 속성이라고 불리는 위치에 특정한 이름과 함께 저장된 값들을 가지고 있는 값입니다. `obj.a`는 `obj`라고 불리는 객체의 `a`라는 속성을 값을 의미합니다. 또한 속성들은 `obj["a"]`으로도 접근이 가능합니다. 이는 2장에서 더 다루겠습니다.
* 동등(Equality): `==` 느슨한 동등(loose-equals), `===` 엄격한 동등(strict-equals), `!=` 느슨한 동등하지 않음(loose not-equals), `!==` 엄격한 동등하지 않음(strict not-equals), 이는 `a == b`와 같이 사용합니다. 

	2장과 "값 & 타입"을 참고해주세요.
* 비교(Comparison): `<` 미만(less than), `>` 초과(greater than), `<=` 이하(less than or loose-equals), `>=` 이상(greater than or loose-equals), 이는 `a <= b`와 같이 사용합니다. 

	2장과 "값 & 타입"을 참고해주세요.
* 논리(Logical): `&&` 그리고(and), `||` 또는(or), 이는 `a || b`와 같이 사용하며 `a` 또는 `b`를 선택합니다. 

    이 연산자들은 `a` 또는 `b` 중 true를 구하기 위한 식처럼 복합적인 조건("Conditionals"을 참고하세요)을 표현하기 위하여 사용합니다.

**참고:** 더 자세한 내용과, 여기서 언급하지 않은 연산자에 대한 얘기는, Mozilla Developer Network (MDN)의 "Expressions and Operators" (https://developer.mozilla.org/en-US/docs/Web/자바스크립트/Guide/Expressions_and_Operators)대한 항목을 보는 것이 좋습니다.

## 값 & 타입

만약 여러분이 휴대폰 대리점의 직원에게 어떤 휴대폰의 가격을 물어봤다고 가정해봅시다. 이때 직원은 여러분에게 휴대폰을 구입하기 위해 지불해야할 금액(세금을 포함한) $99.99라는 숫자(금액)를 말해줄 것입니다. 여러분이 휴대폰 두개를 구매한다고 생각했을 때 이러한 직접적인 숫자는 $199.98이란 금액을 쉽게 암산할 수 있게 합니다.

또 어떤상황에서는 같은 직원이 비슷한 다른 폰을 보여주면서 방금과는 다르게 직접적인 숫자로 금액을 말하지 않고 여러분이 지불해야 하는 예상 비용이 $0.00이라는 의미로써 "무료"라는 단어를 사용할 것입니다. 

후에 충전기가 포함이냐는 물음에는 "예" 또는 "아니오"로 답하게 될 것입니다.

마찬가지로 여러분이 프로그램안에서 값을 표현할 때, 그 값들을 어떻게 사용할지에 따라 나타내는 방식이 다를 것입니다.

아래의 값에 대한 서로 다른 표현들을 프로그래밍 용어로 *타입*이라고 합니다. 자바스크립트는 *원시값*이라고 불리는 아래 각각의 값에 대한 타입을 내장하고 있습니다.

* 여러분에게 수학적인 계산이 필요할때, `number` 타입이 필요할 것입니다.
* 여러분이 값을 화면에 출력하고 싶을 때, `string` 타입이 필요할 것입니다. (한 개 이상의 문자, 단어, 문장을 표현하기 위해서).
* 여러분이 프로그램에서 어떠한 결정을 사용해야하는 로직을 만들 때, 여러분은 `boolean` 타입을 필요로 할 것입니다. (`true` 혹은 `false`를 표현하기 위하여)

소스코드에 직접적으로 포함되어 있는 값들을 우리는 *literals*(이하 리터럴)이라고 말합니다. `string` 리터럴은 큰 따옴표`"..."` 혹은 작은 따옴표`'...'`로 둘러싸서 표현하는데, 이는 문체상의 차이만 존재합니다. `number` 와 `boolean` 리터럴은 단순하게 `42`, `true` 등으로 표현하곤합니다.

생각해보세요:

```js
"I am a string";
'I am also a string';

42;

true;
false;
```

일반적인 프로그래밍언어에서는 `string`/`number`/`boolean` 외에도 *arrays*, *objects*, *functions* 타입 들을 제공합니다. 우리는 이 장과 다음 장에 걸쳐 값과 타입에 대해 더 많이 알게 될 것 입니다.

### 각 타입 사이에서의 변환

여러분이 `number`타입을 가지고 있고 이를 화면에 출력하기 위해서는 `string`타입으로 변환을 해야합니다. 이 변환을 자바스크립트에서는 "강제변환"이라고 합니다. 비슷한 예로, 어떤 사람이 쇼핑몰 페이지에서 금액을 입력하는 칸에 일련의 숫자를 입력했을 때, 그 일련의 숫자는 `string`타입으로 여겨지는데, 여러분이 만약 그 일련의 숫자를 이용하여 수학적인 계산을 해야할 때 이를 `number`타입으로 만들기 위해서 필요한 변환은 *강제변환*이라고 얘기합니다.

자바스크립트는 이러한 *타입*들간의 변환을 강제적으로 하게하는 몇가지 기능을 제공합니다. 예를들어:

```js
var a = "42";
var b = Number( a );

console.log( a );	// "42"
console.log( b );	// 42
```

보시다시피 자바스크립트에 내장된 `Number(..)`함수를 사용하면 다른 타입들을 `number`타입으로 *명시적으로* 강제변환합니다.

하지만 생각해봐야 할 점은 *암시적인* 강제 변환을 필요로 하는 서로 다른 타입의 두 값을 비교할 때 발생하는 현상입니다.

문자열 "99.99"와 숫자 99.99를 비교할 때, 대부분의 사람들은 서로 같다고 생각할 겁니다. 하지만 이 둘은 같은 값을 두 개의 서로 다른 타입과 표현으로 나타냈기 때문에 정확히 같지는 않습니다, 동의하나요? 만약 같다고 한다면, "느슨한 동등"으로 볼 수 는 있겠죠.

위와 같은 상황에서 오는 혼란을 없애기 위해 자바스크립트는 때때로 타입을 강제로 변환시키기도 합니다.

만약 여러분이 `"99.99" == 99.99`의 상황에서 `==`와 같은 느슨한 동등 연산자를 사용한다면, 자바스크립트는 왼쪽의 `"99.99"`의 타입을 오른쪽 `99.99`의 타입인 `number`로 강제로 변환 시킵니다. 그리고 이에 대한 결과로 `99.99 == 99.99`는 `true`를 나타내게 됩니다.

강제변환은 우리를 돕기위해 존재하지만, 이 기능이 어떻게 동작하는 지에 대한 이해가 없다면 우리에게 혼란을 야기할 수 있습니다. 대부분의 자바스크립트 개발자들이 이러한 이해의 과정을 겪지 않습니다. 그렇다보니 강제변환 기능이 프로그램에 예상하지 못한 버그를 만들어내기 때문에, 오히려 이를 피해야 한다고 생각합니다. 더 황당한건 이를 언어적 흠이라고 얘기하는 사람들도 있습니다. 

그러나 강제변환은 *공부할 수 있는 부분*입니다. 좀 더 얘기해보자면 자바스크립트 프로그래밍을 심오하게 접근하고 싶은 사람이라면 당연하게 *공부해야할 부분*입니다. 이러한 탐구는 강제변환에 대한 혼란을 없애줄 뿐만 아니라, 실제로 당신의 프로그램을 더 좋게 만들어 줄 것입니다. 즉 노력을 들여서 공부해볼만한 일이라는 말입니다.

**참고:** 강제변환에 대해 정보가 더 필요하다면 이 책의 2장, 혹은 이 시리즈의 *Types & Grammar*의 4장을 참고해주세요.

## 코드 주석

휴대폰 대리점 직원은 최근에 배포된 핸드폰의 특징이나 회사에서 제공하는 새로운 계획들을 메모해둘지도 모릅니다. 이 메모들은 고객들이 읽기 위한 것이 아닌, 직원들을 위한 것입니다. 그렇지만, 직원이 고객에게 전달해야 할 말에 대한 방법과 이유를 문서로 남겨서 자기 일을 더 잘할 수 있도록 도와줍니다.

코드를 작성하면서 배울 수 있는 중요한 교훈 중 하나는 내가 지금 작성하는 코드가 컴퓨터에만 국한되지 않는다는 것입니다. 즉 컴파일러를 위한 코드를 작성하는 것만큼 개발자를 위한 코드를 작성하는 것도 중요합니다. 

여러분의 컴퓨터는 *컴파일*에서 온 이진수 0과 1로 이루어진 기계 코드에 대해서만 관심이 있습니다. 그리고 여러분은 0과 1로 이루어진 거의 무한한 수의 프로그램을 작성할 수 있습니다. 이러한 맥락에서 여러분이 프로그램을 어떻게 작성할지에 대한 선택은 여러분뿐만이 아닌 다른 팀 구성원, 미래의 여러분 자신을 위한 문제이기도 합니다.

여러분은 정확하게 동작하는 프로그램을 작성해야 할 뿐만 아니라 테스트를 할 때도 의미 있는 프로그램을 작성해야 합니다. 여러분의 변수와 ("변수"를 참고하세요) 함수 ("함수" 참고하세요)를 위한 좋은 이름을 선택하는 노력은 여러분의 프로그램이 좋은 결과를 낼 수 있도록 만듭니다.

하지만 또 다른 중요한 부분은 코드 주석입니다. 여러분의 프로그램에는 단순히 여러분의 프로그램을 사람에게 설명하기 위해 삽입된 텍스트 비트들이 있습니다. 인터프리터/컴파일러는 이 주석들을 항상 무시할 것입니다.

주석 처리가 잘 된 코드를 작성하는 것에 대한 많은 의견이 있습니다; 우리는 실제로 반드시 지켜야만 하는 공통된 규칙을 정의할 수 없습니다. 하지만 일부 발언과 가이드라인은 꽤 유용합니다:

* 주석 없는 코드는 차선책입니다.
* 너무 많은 주석 (예를 들어 한 줄에 하나씩)은 잘 못 작성된 코드라는 뜻입니다.
* 주석은 *무엇*이 아닌 *왜*에 대해 설명해야 합니다. 물론 혼동의 여지가 있다면 부가적으로 *어떻게*에 대해 설명할 수 있습니다.

자바스크립트에서는, 주석을 작성하는 방법이 두 가지 있습니다: 한 줄 주석과 여러 줄 주석

생각해보세요:

```js
// 이것은 한 줄 주석입니다.

/* 그리고 이것은
       여러 줄
             주석입니다.
                      */
```

`//`한 줄 주석은 단일 문장 바로 위에 주석을 달거나 줄의 끝 부분에 주석을 넣을 때 적절합니다. `//`이후에 그 줄에 있는 모든 것은 주석으로 처리됩니다(따라서 컴파일러에 의해 무시됩니다). 한 줄 주석 안에 표현할 수 있는 것에 대한 제한은 없습니다.

생각해보세요:

```js
var a = 42;		// 42는 삶의 의미입니다.
```

`/* .. */` 여러 줄 주석은 여러분의 생각을 여러 줄로 설명할 때 적절합니다.

다음은 여러 줄 주석의 일반적인 사용법입니다:

```js
/* 다음의 값은 우주의 모든 질문에 대해
   답을 한다고 여겨지기 때문에 
   사용됩니다. */
var a = 42;
```

`*/`이 주석의 끝이기 때문에 한 줄의 어디에서든, 심지어 줄의 중간에서도 나타날 수 있습니다. 예를 들어:

```js
var a = /* 임의의 값 */ 42;

console.log( a );	// 42
```

여러 줄 주석 안에서 */은 주석의 끝으로 해석되기 때문에, 주석의 중간에 사용할 수 없는 유일한 값입니다.

여러분은 주석 코드를 작성하는 습관을 시작으로 프로그래밍을 배우고 싶을 것입니다. 이 장의 나머지 부분에서는 제가 뭔가를 설명하기 위해 주석을 사용하는 것을 보실 수 있을 것입니다. 그리고 연습할 때 똑같이 적용하세요. 저를 믿으세요, 여러분이 작성한 코드를 읽는 모든 사람들은 여러분에게 감사할 것입니다!

## 변수

대부분의 유용한 프로그램들은 프로그램의 진행 과정에서 값이 변경될 때마다 추적해야 하며, 여러분의 프로그램이 요구하는 다양한 작업을 수행해야 합니다.

여러분의 프로그램에서 그 일을 가장 쉽게 하는 방법은 *변수*라고 불리는 상징적인 컨테이너에 값을 할당하는 것입니다. -- 이 컨테이너에 있는 값은 필요하다면 시간이 지남에 따라 *변경*할 수 있기 때문에 그렇게 불립니다.

일부 프로그래밍 언어에서, 여러분은 `숫자` 또는 `문자열`과 같은 구체적인 값의 타입을 유지하기 위해 변수 (컨테이너)를 선언합니다. *타입 강제*라고 불리기도 하는 *정적 타이핑*은 일반적으로 의도하지 않은 값의 변환을 방지하여 프로그램 정확성에 대한 이점으로 인용됩니다.

다른 언어들은 변수 대신에 값에 대한 타입을 강조합니다. *동적 타이핑*이라고 불리기도 하는 *약한 타이핑*은, 변수가 언제든지 모든 타입의 값을 유지할 수 있게 합니다. 일반적으로 프로그램의 논리 흐름에서 특정 순간에 값이 가질 수 있는 타입 형식이 무엇이든지 상관없이 하나의 변수가 하나의 값을 나타낼 수 있게 함으로써 프로그램의 유연성에 대한 이점으로 인용됩니다.

자바스크립트는 변수들이 어떠한 *타입* 강제 없이 어떤 *타입*의 값이던 가질 수 있는 후자의 접근법(*동적 타이핑*)을 사용합니다.

앞서 언급했듯이, 우리는 `var` 선언문을 사용해 변수를 선언합니다 -- 이 선언문에서는 *타입*에 대한 다른 정보가 없다는 것에 주목하세요. 이 간단한 프로그램을 생각해보세요:

```js
var amount = 99.99;

amount = amount * 2;

console.log( amount );		// 199.98

// `amount`를 문자열로 변환하고
// 시작 부분에 "$"를 추가하세요.
amount = "$" + String( amount );

console.log( amount );		// "$199.98"
```

`amount` 변수는 숫자 `99.99`를 갖고 시작해, `amount * 2`의 `숫자` 결과인 `199.98`을 저장합니다.

첫 번째 `console.log(..)` 명령어는 *암시적으로* `숫자`값을 `문자열`로 출력하도록 강제합니다.

그리고 `amount = "$" + String(amount)`선언문은 *명시적으로* `199.98`값을 `문자열`로 강제하고 시작 부분에 `"$"`문자를 추가합니다. 이때, `amount`에는 문자열 값 `"$199.98"`이 저장되어 있고, 따라서 두 번째 `console.log(..)` 선언문은 출력하기 위해 어떠한 강제 변환을 할 필요가 없습니다.

자바스크립트 개발자들은 `99.99`, `199.98`, 그리고 `"$199.98"` 각각에 대한 `amount`변수 사용에 대한 유연성에 주목할 것입니다. 정적 타이핑 애호가들은 `amountStr`와 같은 별도의 변수를 사용해 최종적인 값을 나타내는 `"$199.98"`를 저장하는 것을 선호합니다. 왜냐하면 다른 타입이기 때문입니다.

어느 쪽이든, 여러분은 변수의 주된 목적을 설명하면서 프로그램의 진행 과정에서 변하는 실행 값을 저장하는 `amount`에 주목할 것입니다: 프로그램의 *상태*를 관리하는 것

즉, *상태*는 여러분의 프로그램이 실행될 때 값의 변화를 추적합니다.

또 다른 변수의 일반적인 사용법은 값 설정을 집중시키는 것입니다. 변수를 선언하고 그 값을 프로그램 전체에서 *변경하지 않으려고* 할 때 일반적으로 *상수*라고 합니다.

종종 프로그램의 맨 위에 이러한 *상수*들을 선언해, 필요한 경우 한 곳에서 값을 변경하는 것이 편리합니다. 일반적으로 상수로 사용되는 자바스크립트 변수는 대문자로 표시되며, 여러 단어 사이에서는 밑줄 `_`과 함께 사용됩니다.

다음은 좋지 않은 예시입니다:

```js
var TAX_RATE = 0.08;	// 8% 판매 세율

var amount = 99.99;

amount = amount * 2;

amount = amount + (amount * TAX_RATE);

console.log( amount );				// 215.9784
console.log( amount.toFixed( 2 ) );	// "215.98"
```

**참고:** `console.log(..)`가 `console`값에 객체 속성으로 접근한 함수 `log(..)`인 것과 비슷하게 `숫자`값에 접근할 수 있는 `toFixed(..)` 함수가 있습니다. 자바스크립트 `숫자`는 자동으로 달러 형식을 지원하지 않습니다 -- 엔진은 여러분의 의도가 무엇이고 알지 못하고 통화에 대한 타입이 없습니다. `toFixed(..)`는 반올림하고 싶은 `숫자`의 위치에 소수점 이하 자릿수를 지정할 수 있게 하고 필요에 따라 `문자열`을 생성합니다.

`TAX_RATE`변수는 일반적으로 *상수*에 해당합니다 -- 이 프로그램에서 `TAX_RATE` 변수가 변경되지 못한다는 것 외에 특별한 것이 없습니다. 하지만 도시가 판매 세율을 9%로 인상하면, 우리는 프로그램 전체에 `0.08` 값이 여러 번 나오는 것을 발견하고 그 모두를 업데이트하는 대신 한 곳에서 `TAX_RATE`값을 `0.09`로 설정해 여전히 쉽게 프로그램을 업데이트할 수 있습니다.

이 글을 쓸 당시의 최신 버전의 자바스크립트 (일반적으로 "ES6"라고 불리는)에는 `var` 대신 `const`를 사용하여 *상수*를 선언하는 새로운 방법이 포함되어 있습니다:

```js
// ES6:
const TAX_RATE = 0.08;

var amount = 99.99;

// ..
```

상수는 초기 설정 후에 실수로 다른 곳에서 값이 변경되는 것을 방지하는 것을 제외하고, 변경되지 않은 값을 가진 변수와 마찬가지로 유용합니다. 초기 선언 후에 다른 값을 `TAX_RATE`에 할당하려고 하면 여러분의 프로그램은 변경을 거부할 것입니다(그리고 엄격 모드에서는 오류와 함께 실패합니다 -- 2장의 "엄격 모드"를 참고하세요).

그런데, 실수를 방지하기 위한 보호는 정적 유형 타입 강제와 유사하므로, 여러분은 왜 정적 타입이 다른 언어에서 매력적일 수 있는지 알 수 있습니다!

**참고:** 변수에서 여러분의 프로그램에서 사용될 수 있는 다양한 값에 대한 자세한 내용은, 시리즈의 *Types & Grammar* 제목을 참고하세요.

## 블록

여러분이 새 휴대폰을 사려고 할 때, 휴대폰 대리점 직원은 일련의 단계를 거쳐 판매를 완료합니다.

마찬가지로, 코드에서 일련의 문을 그룹화해야 하는 경우가 종종 있는데, 이것을 *블록*이라고 부릅니다. 자바스크립트에서 블록은 중괄호 쌍 `{ .. }` 안에 하나 이상의 문을 감싸서 정의됩니다. 생각해보세요:

```js
var amount = 99.99;

// 일반 블록
{
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

이런 종류의 독립적인 `{ .. }` 일반 블록은 유효하지만, JS 프로그램에서 일반적으로 볼 수 있지 않습니다. 일반적으로 블록은 `if`문("조건"을 참고하세요)이나 반복문("반복"을 참고하세요)과 같은 제어문과 함께 쓰입니다. 예를 들어:

```js
var amount = 99.99;

// amount가 충분히 클까요?
if (amount > 10) {			// <-- `if`와 함께 쓰이는 블록
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

아래의 `if`문에서 볼 수 있듯이, 두 개의 문이 포함된 `{ .. }` 블록은 `if (amount > 10)`뒤에 따라옵니다. 블록 안의 문은 조건을 통과하는 경우에만 실행됩니다.

**참고:** `console.log(amout);`와 같은 대부분의 다른 문과는 다르게, 블록은 세미콜론(`;`)이 필요하지 않습니다.

## 조건

"액정 보호 필름을 $9.99에 추가로 구매하시겠습니까?"라며 휴대폰 대리점 직원이 구매 의사를 물어봅니다. 이때 여러분은 대답하기 위해 우선 지갑이나 은행 계좌의 현재 *상태*를 확인해야 할 수도 있습니다. 하지만 분명한 것은, 이것은 단순히 "예" 혹은 "아니오"라고 대답하면 되는 질문입니다.

프로그램에서 *조건*(일명 결정)을 표현하는 데는 몇 가지 방법이 있습니다.

가장 일반적인 방법은 `if`문입니다. 핵심만 말하면, "*만약* 이 조건이 참이라면, 다음을 따르십시오...". 예를 들면:

```js
var bank_balance = 302.13;
var amount = 99.99;

if (amount < bank_balance) {
	console.log( "I want to buy this phone!" );
}
```

`if`문은 `( )` 괄호 사이에 `true` 혹은 `false`로 평가될 수 있는 표현식이 필요합니다. 이 프로그램에는 `bank_balance` 변수의 값에 따라서 `true` 혹은 `false`로 평가되는 `amount < bank_balance` 표현식이 있습니다.

조건이 참이 아닐 때는 `else`절이라 불리는 대안을 마련할 수도 있습니다. 생각해보세요:

```js
const ACCESSORY_PRICE = 9.99;

var bank_balance = 302.13;
var amount = 99.99;

amount = amount * 2;

// 추가 구매를 감당할 수 있을까요?
if ( amount < bank_balance ) {
	console.log( "I'll take the accessory!" );
	amount = amount + ACCESSORY_PRICE;
}
// 그렇지 않다면:
else {
	console.log( "No, thanks." );
}
```

보세요, 만약 `amount < bank_balance`가 `true`라면 `"I'll take the accessory!"`가 출력되고 `amount`변수에 `9.99`가 더해질 것입니다. 그렇지 않다면, `else` 절에서 정중하게 `"No, thanks."`를 출력하고 `amount`는 변경되지 않을 것입니다.

앞서 "값 & 타입"에서 논의한 바와 같이, 이미 기대한 타입이 아닌 값은 종종 해당 타입으로 강제 변환 됩니다. `if`문은 `boolean`값을 기대하지만, `boolean`이 아닌 다른 것을 전달하면 강제 변환 됩니다.

자바스크립트는 "거짓"으로 추정되는 특정 값(`boolean`으로 강제 변환 될 때 `false`가 되는 값 --`0`이나 `""` 등)들의 목록을 정의합니다. 이 목록에 없는 다른 모든 값은 자동으로 "참"(`boolean`으로 강제 형변환 하면 `true`가 되는 값)으로 추정됩니다. "참"으로 추정되는 값에는 `99.99`나 `"free"`와 같은 값이 포함됩니다. 2장의 "참 추정 & 거짓 추정"항목에서 더 자세한 내용을 참고해주세요.

*조건*은 `if` 이외의 다른 형태도 있습니다. 예를 들어, `switch`문은 일련의 `if..else`문에 대한 축약어로 사용될 수 있습니다.(2장을 참고하세요) 반복문("반복"을 참고하세요)은 *조건*을 사용하여 반복을 계속 진행할지 또는 중지할지를 결정합니다.

**참고:** *조건*의 조건식에서 암시적으로 발생할 수 있는 강제 변환에 대한 더 자세한 내용은 이 시리즈 중 *Types & Grammar*의 4장을 참고하세요.

## 반복

한창 바쁠 때는, 휴대폰 대리점 직원과 통화를 해야 하는 통화 대기 고객 명단이 생깁니다. 목록에 손님들이 있는 동안에는, 직원은 다음 손님을 계속 응대 해야만 합니다.

특정 조건이 실패할 때까지 일련의 동작을 반복 -- 즉, 조건이 유지되는 동안만 반복 -- 하는 것이 프로그래밍 반복 작업입니다.; 다른 형태를 취할 수 있지만, 모두 이 기본 동작을 만족합니다.

반복문은 조건식과 (일반적으로 `{ .. }`와 같은) 블록을 포함합니다. 반복문 블록이 실행될 때마다, 이를 *이터레이션*이라고 합니다.

예를 들어, `while`문과 `do..while`문 형식은 조건이 더는 `true`가 아닌 것으로 평가될 때까지 블록 안의 문을 반복하는 개념을 보여줍니다.:

```js
while (numOfCustomers > 0) {
	console.log( "How may I help you?" );

	// 손님을 도와줍니다...

	numOfCustomers = numOfCustomers - 1;
}

// 한편:

do {
	console.log( "How may I help you?" );

	// 손님을 도와줍니다...

	numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

이 두 가지 반복문의 단 한 가지 유일한 차이점은 조건문이 첫 번째 반복 이전에 검사되는지 (`while`) 아니면 첫 번째 반복 이후에 검사되는지 (`do..while`)입니다.

어느 형식이든, 조건식 검사가 `false`인 경우, 다음 반복은 실행되지 않습니다. 즉, 조건식이 처음부터 `false`이면, `while`문은 전혀 실행되지 않지만, `do..while`문은 첫 번째 반복은 실행될 것입니다.

때때로 여러분은 특정 범위의 수(`0`부터 `9`까지의 10개의 수 처럼)를 세기 위해 반복을 합니다. 반복문에서 `i`와 같은 반복 변수를 `0`으로 설정하고 반복 주기마다 `1`씩 증가하도록 하면 가능합니다.

**주의:** 다양한 역사적 이유로, 프로그래밍 언어는 대부분 `1` 대신 `0`부터 수를 세는 관습이 있습니다. 여러분이 이렇게 생각하는 방식에 익숙하지 않다면, 처음에는 조금 혼란스러울 것입니다. 좀 더 익숙해질 수 있도록 잠시 시간을 갖고 `0`부터 수를 세는 연습을 해보세요!

조건은 반복문 안에 암묵적인 `if`문이 있는 것처럼, 매 반복에서 검사됩니다.

자바스크립트의 `break`문을 사용해 반복을 멈출 수 있습니다. 또한, 멈추는(`break`ing) 방법이 없이 영원히 돌아가는 반복문을 만드는 것이 꽤나 쉽다는 것도 알 수 있습니다.

한번 확인해볼까요:

```js
var i = 0;

// `while..true`반복문이 영원히 실행되겠죠?
while (true) {
	// 반복을 멈춰볼까요?
	if ((i <= 9) === false) {
		break;
	}

	console.log( i );
	i = i + 1;
}
// 0 1 2 3 4 5 6 7 8 9
```

**주의:** 위의 예시가 여러분의 반복문에 반드시 사용하게 될 실질적인 형태는 아닙니다. 단지 설명하기 위한 목적으로 보여드렸습니다.

`while`(혹은 `do..while`)이 수동으로 작업을 수행할 수 있는 반면에, 같은 목적을 위한 `for`문이라는 또 다른 구문 형식이 있습니다.:

```js
for (var i = 0; i <= 9; i = i + 1) {
	console.log( i );
}
// 0 1 2 3 4 5 6 7 8 9
```

보시다시피, 두 가지 경우 모두 첫 10번의 반복(`i`가 `0`부터 `9`까지)에 대해서는 조건식 `i <= 9`가 `true`가 됩니다. 하지만 `i`가 `10`일 때 조건식은 `false`가 됩니다.

`for`문 에는 세 개의 절이 있습니다.: 초기식(`var i=0`), 조건식(`i <= 9`), 증감식(`i = i + 1`). 따라서 반복문의 반복 횟수를 세보려면 `for`은 더 간단하며 이해하고 작성하기에 쉬운 형식입니다.

예를 들어, 객체(2장을 참고하세요)의 속성과 같은 특정 값들을 반복하기 위한 또 다른 특별한 반복문 형식이 있습니다. 여기서 암시적 조건 검사는 모든 속성에 대해 반복했는지의 여부만 판단합니다. "조건이 실패할 때까지 반복한다"는 개념은 반복문의 형식에 상관없이 변하지 않습니다.

## 함수

보통 회사는 처음에 규칙을 정하고 반복해서 재사용 해야하는 일들에 대해, 그러한 기능들이 내장되어 있는 기기(컴퓨터, 태블릿 등)들을 제공합니다. 기기를 제공받은 휴대폰 대리점 직원은 매번 세금과 최종 구매 금액의 계산을 위하여 계산기를 들고다닐 필요가 없어질 것입니다.

이와 유사하게, 프로그램은 코드 수행을 재사용 가능한 단위로 나눌 것입니다. 되풀이해서 반복되게 반복되는 대신에(말장난 입니다!). 이렇게 하는 방법이 함수를 정의하는 것입니다.

함수는 일반적으로 이름으로 호출 가능한 코드의 고유한 부분입니다, 그리고 내부 코드는 매번 실행 될 것입니다. 생각해보세요:

```js
function printAmount() {
	console.log( amount.toFixed( 2 ) );
}

var amount = 99.99;

printAmount(); // "99.99"

amount = amount * 2;

printAmount(); // "199.98"
```

함수는 추가로 인자들(매개변수라고도 하는)을 받을 수 있습니다. 그리고 그 함수들은 경우에 따라 값을 반환할수 있습니다.

```js
function printAmount(amt) {
	console.log( amt.toFixed( 2 ) );
}

function formatAmount() {
	return "$" + amount.toFixed( 2 );
}

var amount = 99.99;

printAmount( amount * 2 );		// "199.98"

amount = formatAmount();
console.log( amount );			// "$99.99"
```

`printAmount(..)` 함수는 `amt` 매개변수를 가질 수 있고 `formatAmount()`함수는 값을 반환합니다. 이 두가지 형식은 당연히 한 함수에서 함께 사용 할 수 있습니다.

반복되는 코드에 대해서 함수로 사용할 수 있습니다. 그리고 함수들을 한번만 호출 할지라도, 관련된 코드를 고유한 집합으로 묶어서 사용하기도 유용합니다.

생각해보세요:

```js
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
	// 세금을 포함한 금액 계산하기
	amt = amt + (amt * TAX_RATE);

	// 새롭게 계산된 금액 돌려주기
	return amt;
}

var amount = 99.99;

amount = calculateFinalPurchaseAmount( amount );

console.log( amount.toFixed( 2 ) );		// "107.99"
```

비록 calculateFinalPurchaseAmount(..) 가 한번만 호출 되더라도, 기능을 고유한 함수로 나누는 것은 코드(the amount = calculateFinal... statement)를 더 명확하게 해줍니다. 만약 함수가 더 많은 문을 가지고 있으면, 그 장점이 훨씬 더 부각됩니다.

### 스코프

휴대폰 대리점 직원에게 휴대폰 기종을 물어봤을 때 그 기종이 없다면 직원은 가게의 재고만 팔 수 있기 때문에 여러분에게 휴대폰을 팔 수 없을 것 입니다. 그리고 여러분은 다른 가게에 가서 여러분이 원하는 기종이 있는지 찾아봐야 합니다.

프로그래밍도 이와 같은 개념을 가지고 있습니다. *스코프* (기술적으로 말하자면 *렉시컬 스코프*). 자바스크립트 안에서 각각의 함수는 각자의 스코프를 가지고 있습니다. 스코프는 기본적으로 변수와 이름으로 어떤 방법으로 접근하는가에 대한 규칙들의 집합입니다. 함수의 스코프에서 작성되는 코드만이 그 함수의 변수에 접근할 수 있습니다.

변수 이름은 같은 스코프 안이라면 특별해야 합니다. 즉 각기 다른 변수 `a`는 같이 있을 수 없습니다. 하지만 같은 변수의 이름일지라도 다른 스코프에 속해 있다면 가능합니다.

```js
function one() {
	// `a`는 one 함수에만 속해 있습니다.
	var a = 1;
	console.log( a );
}

function two() {
	// `a`는 two 함수에만 속해 있습니다.
	var a = 2;
	console.log( a );
}

one();		// 1
two();		// 2
```

또한 스코프는 다른 스코프 안에 겹쳐 질 수 있습니다. 마치 광대가 생일 파티에서 풍선 속에 풍선을 부는 것처럼요. 만약 한 스코프가 다른 스코프 안에 겹쳐진다면 가장 깊숙이 있는 스코프는 다른 스코프의 변수에 접근할 수 있습니다.

생각해보세요:

```js
function outer() {
	var a = 1;

	function inner() {
		var b = 2;

		// `a` and `b`에 접근이 가능합니다.
		console.log( a + b );	// 3
	}

	inner();

	// `a`만 접근 할수 있습니다.
	console.log( a );			// 1
}

outer();
```

렉시컬 스코프(정적스코프)의 규칙은 한 스코프 안에 있는 코드들은 다른 스코프 또는 밖에 있는 어느 스코프든 접근할 수 있습니다. 

그래서 코드 안에 `inner()` 함수는 두 변수 `a`와 `b`에 접근이 가능하지만 `outer()`  함수내부에 코드는 `a`만 가능합니다. `b`에 접근이 안 되는 이유는 `inner()` 함수 안에만 있기 때문입니다.

이전 코드 스니펫으로 다시 돌아 가봅시다: 

```js
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
	// 세금이 포함된 새로운 금액을 계산
	amt = amt + (amt * TAX_RATE);

	// 새로운 금액을 반환하기
	return amt;
}
```

비록 상수(변수) `TAX_RATE`값을 `calculateFinalPurchaseAmount(..)`함수안에 전달하지 않아도, 렉시컬 스코프에 의해서 함수 내부에서 접근이 가능합니다.

**참고:** 렉시컬 스코프에 관해 더 알고 싶으시면 시리즈 중 *Scope & Closures* 에 처음 세개의 장 을 참고하면 됩니다.

## 연습

프로그래밍을 배우는데 있어서 연습 외에 좋은 대안은 없습니다. 제가 명확하게 글을 쓴다고 할지라도 그것이 당신을 프로그래머로 만들 수는 없습니다.

앞에 언급한 글을 되새기면서 이 장에서 우리가 배운 것들을 연습해봅시다. 제가 제시하는 "필수 사항"을 먼저 여러분의 코드로 작성하고, 그 다음 아래의 코드들을 보면서 제가 어떻게 접근했는지를 참고하세요.

* 휴대폰의 총 구매가격을 계산하는 코드를 써보세요. 당신이 은행 계좌에 가지고 있는 돈이 떨어질 때까지 휴대폰 구매를 계속할 것입니다(힌트: loop!) 각각의 휴대폰에 액세서리 또한 당신의 허용하는 구매 한계치까지 구매할 것입니다.
* 구매 금액을 계산한후에, 세금을 더하고, 그리고 나서 적절한 형식으로 계산한 구매금액을 출력하세요.
* 마지막으로 당신의 은행 잔액을 확인하며 더 구매를 할 수 있는지 확인합니다. 최종적으로, 여러분의 통장에 남은 잔액이 충분한지 확인을 합니다.
* "tax rate(세율)", "phone price(휴대폰 가격)", "accessory price(액세서리 가격)", "spending threshold(한도 금액)," "bank account balance(은행 잔액)" 등의 변수를 설정합니다.
* 세금을 계산하기 위한 함수를 정의합니다. 또한 금액은 "$"와 소수점 두 자리 까지 정도로 맞춥니다.
* **보너스 챌린지:** input을 포함해 보세요. 이전 "Input"에서 다룬 prompt(..)를 가지고 input을 코드에 넣어보세요. 예를들어서, 사용자의 은행잔고를 바로 알려줄 수 있습니다. 창의력을 더한 즐거운 코딩을 해보세요!

그럼 한번 해보세요! 단, 여러분이 직접 해볼 때까지 제 코드를 보지 마세요.

**참고:** 이 책은 자바스크립트 책이기 때문에, 연습문제는 자바스크립트로 풀 것입니다. 다른 언어가 편하다면 그 언어를 사용하셔도 됩니다!

아래는 제가 작성한 해당 문제의 솔루션입니다.

```js
const SPENDING_THRESHOLD = 200;
const TAX_RATE = 0.08;
const PHONE_PRICE = 99.99;
const ACCESSORY_PRICE = 9.99;

var bank_balance = 303.91;
var amount = 0;

function calculateTax(amount) {
	return amount * TAX_RATE;
}

function formatAmount(amount) {
	return "$" + amount.toFixed( 2 );
}

// 잔고가 있을 때 까지 휴대폰을 구입
while (amount < bank_balance) {
	// 새로운 휴대폰을 구입!
	amount = amount + PHONE_PRICE;

	// 액세서리까지 구입하는 것이 충분할까?
	if (amount < SPENDING_THRESHOLD) {
		amount = amount + ACCESSORY_PRICE;
	}
}

// 세금 내는 것을 잊지말기!
amount = amount + calculateTax( amount );

console.log(
	"Your purchase: " + formatAmount( amount )
);
// 구매 금액: $334.76

// 구매하기에 금액이 정말 충분한가?
if (amount > bank_balance) {
	console.log(
		"You can't afford this purchase. :("
	);
}
// 구매를 하기에 현재 잔액이 충분하지 않습니다. :(
```

**참고:** 이 자바스크립트 프로그램을 실행시키는 가장 간단한 방법은 당신의 인터넷 브라우저 개발자 콘솔에 코드를 입력하는 것입니다.

어떻게 했나요? 제 코드를 이미 보았기 때문에 그렇게 힘든 것은 아닐 것입니다. 또한 몇 개의 변수를 변경해서 다른 값으로 이 프로그램이 어떻게 실행되는지 시도해 보세요.

## 리뷰

프로그래밍을 배우는 것은 복잡하거나 엄청난 과정이 있어야 하는 건 아닙니다. 몇 가지 기본개념만 가지고 있으면 됩니다.

이것은 마치 벽돌을 쌓는것과 같습니다. 높은 타워를 짓는다고 생각해보세요. 당신은 벽돌을 층층이 위로 쌓는 것부터 시작할 것입니다. 프로그래밍도 이와 같습니다. 여기 가장 기본이 되는 몇 개의 빌딩 블록이 있습니다.

* 값에 대한 작업을 수행하는 *연산자*
* `숫자` 나 `문자열`의 결괏값 등같이 다른 종류에 작업을 실행하는 값과 *타입*
* 프로그램이 실행되는 동안 데이터를 저장 할 (*스테이트*  라고도 한다.) *변수*
* `if` 조건문과 같은 결정을 할 수 있는 *조건*
* 조건이 참이 될 때까지 반복해서 작업하는 *루프*
* 논리적이고 재사용이 가능한 코드로 정리할 수 있는 *함수*

주석은 더 읽기 쉽게 쓸 수 있도록 하는 효율적인 방법 중 하나입니다. 주석을 사용함으로써, 문제가 생겼을 때 코드를 더 쉽게 이해하고, 유지보수와 수정을 할 수 있습니다.

마지막으로 연습의 힘을 무시하지 마세요. 코드를 배우는 가장 좋은 방법은 직접 코드를 써보는 것 입니다.

여러분은 잘하고 있습니다. 지금까지 여러분이 잘 따라와 주셔서 기쁩니다. 앞으로도 계속 열심히 하세요. 다른 초보자 프로그래밍 자료들(책, 블로그, 온라인 코스 등등) 또한 찾아보는 것도 잊지 마세요. 간단한 소개 정도 이지만 이 장과 이 책은 좋은 시작점입니다.

다음 장에서는 이 장에서 다뤘던 많은 개념들을 리뷰하겠지만, 나머지 시리즈 전체에 걸쳐 더 자세히 주요 주제들을 더욱더 자세히 자바스크립트 특유의 관점에서 다뤄질 것입니다.
